| Category     | No. | Problem Statement                                  |
| ------------ | --- | -------------------------------------------------- |
| **Fixed**    | 1   | More / Min subarray of size **K**                  |
|              | 2   | Find **-ve** in every window of size **K**         |
|              | 3   | Count occurrences of anagrams                      |
|              | 4   | Maximum of all subarrays of size **K**             |
|              | 5   | Maximum of minimum for every window size           |
| **Variable** | 1   | Largest / Smallest subarray with sum **K**         |
|              | 2   | Longest sub-string with **K** distinct characters  |
|              | 3   | Longest substring with **no repeating characters** |
|              | 4   | Pick toys                                          |
|              | 5   | Minimum window substring                           |

reference vedios : https://www.youtube.com/playlist?list=PL_z_8CaSLPWeM8BDJmIYDaoQ5zuwyxnfj

1Ô∏è‚É£ Maximum / Minimum Subarray of Size K

| Thing         | Maximum      | Minimum      |
| ------------- | ------------ | ------------ |
| Variable      | `maxSum`     | `minSum`     |
| Initial value | `-Infinity`  | `Infinity`   |
| Update        | `Math.max()` | `Math.min()` |

Problem Name: Maximum Sum Subarray of Size K

Goal:
‡§π‡§∞ size K ‡§ï‡•Ä subarray ‡§ï‡§æ sum ‡§®‡§ø‡§ï‡§æ‡§≤‡§ï‡§∞ maximum / minimum ‡§¢‡•Ç‡§Å‡§¢‡§®‡§æ

function maxSumSubarray(arr, k) {
  let i = 0, j = 0, sum = 0, maxSum = -Infinity;

  while (j < arr.length) {
    sum += arr[j];

    if (j - i + 1 < k) j++;
    else {
      maxSum = Math.max(maxSum, sum);
      sum -= arr[i];
      i++; j++;
    }
  }
  return maxSum;
}


2Ô∏è‚É£ First Negative Number in Every Window of Size K

Problem Name: Find First Negative Integer in Every Window of Size K
Goal: ‡§π‡§∞ window ‡§Æ‡•á‡§Ç ‡§™‡§π‡§≤‡§æ negative number ‡§¨‡§§‡§æ‡§ì

function firstNegative(arr, k) {
  let i = 0, j = 0;
  let queue = [];
  let result = [];

  while (j < arr.length) {
    if (arr[j] < 0) queue.push(arr[j]);

    if (j - i + 1 < k) j++;
    else {
      result.push(queue.length ? queue[0] : 0);

      if (arr[i] === queue[0]) queue.shift();
      i++; j++;
    }
  }
  return result;
}



3Ô∏è‚É£ Count Occurrences of Anagrams

Problem Name: Count Occurrences of Anagrams in a String

Goal: String ‡§Æ‡•á‡§Ç ‡§ï‡§ø‡§§‡§®‡•á anagrams ‡§Æ‡•å‡§ú‡•Ç‡§¶ ‡§π‡•à‡§Ç

function countAnagrams(str, pat) {
  let map = {};
  for (let ch of pat) map[ch] = (map[ch] || 0) + 1;

  let count = Object.keys(map).length;
  let i = 0, j = 0, ans = 0;

  while (j < str.length) {
    if (map[str[j]] !== undefined) {
      map[str[j]]--;
      if (map[str[j]] === 0) count--;
    }

    if (j - i + 1 < pat.length) j++;
    else {
      if (count === 0) ans++;

      if (map[str[i]] !== undefined) {
        if (map[str[i]] === 0) count++;
        map[str[i]]++;
      }
      i++; j++;
    }
  }
  return ans;
}

4Ô∏è‚É£ Maximum of All Subarrays of Size K

Problem Name: Sliding Window Maximum

Goal: ‡§π‡§∞ window ‡§ï‡§æ maximum element

function maxOfSubarrays(arr, k) {
  let i = 0, j = 0;
  let deque = [];
  let result = [];

  while (j < arr.length) {
    while (deque.length && deque[deque.length - 1] < arr[j]) {
      deque.pop();
    }
    deque.push(arr[j]);

    if (j - i + 1 < k) j++;
    else {
      result.push(deque[0]);
      if (arr[i] === deque[0]) deque.shift();
      i++; j++;
    }
  }
  return result;
}


üü® VARIABLE SIZE SLIDING WINDOW
1Ô∏è‚É£ Largest / Smallest Subarray with Sum K

Problem Name:

Longest Subarray with Sum K

function longestSubarraySumK(arr, k) {
  let i = 0, j = 0, sum = 0, maxLen = 0;

  while (j < arr.length) {
    sum += arr[j];

    while (sum > k) {
      sum -= arr[i];
      i++;
    }

    if (sum === k) {
      maxLen = Math.max(maxLen, j - i + 1);
    }
    j++;
  }
  return maxLen;
}

2Ô∏è‚É£ Longest Substring with K Distinct Characters
function longestKDistinct(s, k) {
  let map = {}, i = 0, maxLen = 0;

  for (let j = 0; j < s.length; j++) {
    map[s[j]] = (map[s[j]] || 0) + 1;

    while (Object.keys(map).length > k) {
      map[s[i]]--;
      if (map[s[i]] === 0) delete map[s[i]];
      i++;
    }
    maxLen = Math.max(maxLen, j - i + 1);
  }
  return maxLen;
}

3Ô∏è‚É£ Longest Substring Without Repeating Characters
function longestUniqueSubstring(s) {
  let set = new Set();
  let i = 0, maxLen = 0;

  for (let j = 0; j < s.length; j++) {
    while (set.has(s[j])) {
      set.delete(s[i]);
      i++;
    }
    set.add(s[j]);
    maxLen = Math.max(maxLen, j - i + 1);
  }
  return maxLen;
}

4Ô∏è‚É£ Pick Toys

Problem Name:

Longest Substring with At Most 2 Distinct Characters

function pickToys(s) {
  let map = {}, i = 0, maxLen = 0;

  for (let j = 0; j < s.length; j++) {
    map[s[j]] = (map[s[j]] || 0) + 1;

    while (Object.keys(map).length > 2) {
      map[s[i]]--;
      if (map[s[i]] === 0) delete map[s[i]];
      i++;
    }
    maxLen = Math.max(maxLen, j - i + 1);
  }
  return maxLen;
}

5Ô∏è‚É£ Minimum Window Substring
function minWindow(s, t) {
  let map = {};
  for (let ch of t) map[ch] = (map[ch] || 0) + 1;

  let count = t.length;
  let i = 0, minLen = Infinity, start = 0;

  for (let j = 0; j < s.length; j++) {
    if (map[s[j]] > 0) count--;
    map[s[j]] = (map[s[j]] || 0) - 1;

    while (count === 0) {
      if (j - i + 1 < minLen) {
        minLen = j - i + 1;
        start = i;
      }
      map[s[i]]++;
      if (map[s[i]] > 0) count++;
      i++;
    }
  }
  return minLen === Infinity ? "" : s.substring(start, start + minLen);
}

